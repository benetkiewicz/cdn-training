---
title: Various Adjustments to Cache Settings part 2
subtitle: How to change caching policy using VCL
premium: true
---

In Lesson 5 we adjusted cache settings for `/api/getfastlyuidate` using Fastly UI. Later, in lesson 6, we learned that there are VCL subroutines where we can plug in to achieve certain effects in various stages of the request-response pipeline. Is Fastly *Cache settings* UI connected somehow with low-level VCL? It sure is!

Let's navigate to *Show VCL*, which can be found at the top in the main Service configuration screen:

![Show VCL](../../../public/lesson7/view-vcl.png)

From there, use built-in browser search and find `getfastlyuidate` string, which is the name of the enpoint for which we adjusted cache settings via UI. If you'll scroll up a bit to find the surrounding content of the snippet, you'll find something like:
```varnish

sub vcl_fetch {
  declare local var.fastly_disable_restart_on_error BOOL;
#--FASTLY FETCH BEGIN

...

# priority: 10
  if ( req.url.path == "/api/getfastlyuidate" ) {
      # Getdate Fastly UI Cache
      set beresp.ttl = 15s;
      set beresp.grace = 0s;
      return(deliver);
  }

...

#--FASTLY FETCH END

```

That is a proof that everything that happens in your CDN service is just a bunch of VCL subroutines. User interface that Fastly provides is just a one way of managing that code (sometimes not the most convenient). Knowing how it looks like under the hood may sometimes help you understand why your configuration works in a certain way or debug issues.

## Adjusting Cache Time via VCL

In order to do that and not have anything else to interfere with our tests, let's prepare a new date endpoint:

```javascript

app.get('/api/getttldate', (req, res) => {
  res.send(new Date().toUTCString());
});
```

From our previous lessons we know that we need to plug into the `vcl_receive` subroutine, as it is responsible for processing incoming client requests and determining how they should be handled. We also have a pretty good idea of how our snippet should look like to do the trick by looking at the code that was generated by the Fastly UI above. The VCL property that represents cache entry freshness is `beresp.ttl`. The common pitfall in this case is that this is not enough because deep in the Fastly documentation there is the following statement:

> If the response does not have any of Cache-Control: max-age, Cache-Control: s-maxage or Surrogate-Control: max-age headers, set beresp.ttl to the fallback TTL configured for your Fastly service. [Learn more in the Fastly documentation](https://www.fastly.com/documentation/reference/vcl/variables/backend-response/beresp-ttl/).

Since our endpoint is 100% vanilla and does not respond with any of the cache-controlling headers, we need to pick something from the list. We will use the `Cache-Control: max-age=0` header to ensure that browsers do not use client-side caching for the response. This setup should yield consistent results when testing with cacheless tools like *curl* as well as with internet browsers, without requiring adjustments in Developer tools.

To summarize, we need the following snippet:
- **Name**: Adjust TTL
- **Type**: fetch
- **VCL**:
```varnish

if (req.url.path == "/api/getttldate") {
  set beresp.http.Cache-Control = "max-age=0";
  set beresp.ttl = 10s;
}
```

And sure enough - `/api/getttldate` endpoint configured that way responds with a fresh date every ~10s. 

It is also worth testing this in the browser to see how it obeys the `Cache-Control` header:

1. The first call (*MISS*) gets an HTTP 200 OK response.
2. `max-age: 0` tells the browser that the response is immediately stale.
3. The next browser request goes with the `if-none-match` request header to confirm if the cached resource is still valid.
4. The POP responds with HTTP 304 Not Modified, so the browser uses the cached copy.